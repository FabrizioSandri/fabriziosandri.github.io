<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="adA2euCk5kykbeBzBFe7a-qGnkIiaI7x3jJgqrfEEIo"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Advanced fuzz testing with DeepState and Valgrind | Fabrizio Sandri </title> <meta name="author" content="Fabrizio Sandri"> <meta name="description" content="An advanced fuzz testing description using DeepState in conjunction with Valgrind"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico?77b41fb878aeb1e52dc168c0807c497e"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://fabriziosandri.github.io/blog/2022/advanced-deepstate/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Fabrizio</span> Sandri </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> </ul> </div> </div> </nav> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Advanced fuzz testing with DeepState and Valgrind</h1> <p class="post-meta"> Created on May 27, 2022 </p> <p class="post-tags"> <a href="/blog/2022"> <i class="fa-solid fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/google-summer-of-code"> <i class="fa-solid fa-hashtag fa-sm"></i> Google Summer of Code</a>   <a href="/blog/tag/deepstate"> <i class="fa-solid fa-hashtag fa-sm"></i> DeepState</a>   <a href="/blog/tag/valgrind"> <i class="fa-solid fa-hashtag fa-sm"></i> Valgrind</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="advanced-fuzz-testing">Advanced fuzz testing</h1> <p>In the previous posts we have seen how to use DeepState to find simple errors in programs. The problem of the basic fuzz testing approach is that it does not allow us to detect more subtle issues, such as memory faults. In this article we introduce and explain a more advanced fuzz testing approach using the Valgrind memcheck tool and DeepState</p> <h2 id="valgrind-introduction">Valgrind introduction</h2> <p>Valgrind is a debugging and profiling tool for Linux applications. The Valgrind distribution comes with a set of useful tools: a thread error detector (Helgrind), a cache profiler (Cachegrind), a heap profiler(Massif), a memory problem analyzer (Memcheck), and other tools are included in the Valgrind suite <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>. For our purpose and interest we will focus uniquely on the Memcheck tool. This tool allows you to do an advanced memory analysis to identify two types of memory errors:</p> <ul> <li>Memory leaks</li> <li>Memory errors</li> </ul> <p>The first is related to missed frees: a software allocates memory in the heap dynamically and then forgets to free it. The latter is caused by more subtle errors, such as reading or writing from uninitialized memory locations: a program writes some bytes in a memory location that has not been initialized. Valgrind has a module called Memcheck that can help you find these kinds of issues.</p> <h3 id="usage">Usage</h3> <p>With some simple steps we can perform an advanced memory analysis over a compiled binary. Before the analysis can take place, in order to have as much information as possible from the analysis results such as the error line number, it’s convenient to compile the program by passing the <code class="language-plaintext highlighter-rouge">-g</code> parameter to the <code class="language-plaintext highlighter-rouge">g++</code> compiler. This option will produce more debugging information that will be included in the resulting binary.</p> <h3 id="sample-usage">Sample usage</h3> <p>The following is a description of the analysis procedure for a basic C++ program that allocates but does not release memory bytes. The program is reported in the following code snippet. As you can see the malloc invocation isn’t followed by a free, thus what we are expecting from Valgrind is a warning from the Memcheck tool about the missing free.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">){</span>
    <span class="c1">// allocates some space for 5 integers</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">sample</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div> <p>As previously noted, the program should be constructed using the <code class="language-plaintext highlighter-rouge">-g</code> argument to provide greater information about any mistakes that may occur during the analysis. Another useful option is <code class="language-plaintext highlighter-rouge">--leak-check=full</code> which performs a full analysis for memory leak problems at the end of the execution.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-o</span> program <span class="nt">-g</span> program.cpp
</code></pre></div></div> <p>Now it is possible to run Valgrind by specifying the tool to use with the <code class="language-plaintext highlighter-rouge">--tool</code> parameter</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind <span class="nt">--tool</span><span class="o">=</span>memcheck ./program
</code></pre></div></div> <p>The result for this analysis will look similar to the followng one</p> <pre><code class="language-log">==108488== Memcheck, a memory error detector
==108488== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==108488== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info
==108488== Command: ./program
==108488== 
==108488== 
==108488== HEAP SUMMARY:
==108488==     in use at exit: 20 bytes in 1 blocks
==108488==   total heap usage: 2 allocs, 1 frees, 72,724 bytes allocated
==108488== 
==108488== 20 bytes in 1 blocks are definitely lost in loss record 1 of 1
==108488==    at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==108488==    by 0x109151: main (program.cpp:5)
==108488== 
==108488== LEAK SUMMARY:
==108488==    definitely lost: 20 bytes in 1 blocks
==108488==    indirectly lost: 0 bytes in 0 blocks
==108488==      possibly lost: 0 bytes in 0 blocks
==108488==    still reachable: 0 bytes in 0 blocks
==108488==         suppressed: 0 bytes in 0 blocks
==108488== 
==108488== For lists of detected and suppressed errors, rerun with: -s
==108488== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</code></pre> <p>The error summary shows that there is an error, in particular if we look at the leak summary we can see that 20 bytes are lost. So the question seems quite straightforward but, where does these 20 bytes come from? If we read carefully the valgrind description the error is found in the main function of our code at line <code class="language-plaintext highlighter-rouge">5</code> as stated by the following message</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">==108488== by 0x109151: main (program.cpp:5)</code></p> </blockquote> <p>The error in fact comes from the call to the <code class="language-plaintext highlighter-rouge">malloc</code> function that allocates <code class="language-plaintext highlighter-rouge">5 * sizeof(int) = 5 * 4 bytes = 20</code> contiguous bytes in heap but doesn’t free them. Note that the size of an integer is compiler and architecture dependent: in my case the size of a single int in memory is 4 bytes.</p> <h2 id="deepstate-and-valgrind">DeepState and Valgrind</h2> <p>Let’s take a closer look at how Valgrind may be used in conjunction with the fuzzing approaches described in my earlier postings. As previously stated, basic fuzz testing is restricted in its ability to detect just certain types of programming problems. Consider combining the power of Valgrind memory checks with the benefits of fuzz testing. That is precisely what we will explore in this section.</p> <p>Fuzz testing programs to find memory safety errors using Valgrind and DeepState allows to increase the probability of finding subtle errors.</p> <h3 id="use-case-example">Use case example</h3> <p>Assume you’re writing a function that accepts a pointer to the beginning of a string, copies it into a new heap-allocated string, and then frees it. Consider that while developing this function, the developer forgot about the size of the source string. A careful reader would have caught the mistake and addressed the problem, however we want to understand how Valgrind with the auxiliary of DeepState could quickly find the problem. As you may have seen, the issue is caused by two factors:</p> <ul> <li>the contiguous memory area pointed by <code class="language-plaintext highlighter-rouge">newStr</code> can contain a string of at most 20 characters;</li> <li>the <code class="language-plaintext highlighter-rouge">memcpy</code> function doesn’t check for any terminating null character.</li> </ul> <p>This means that if someone passes as input parameter a string longer than 20 character, an heap overflow occur <sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">copyAndFreeString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">source</span><span class="p">){</span>
    <span class="c1">// allocates some space for 20 characters</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">newStr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">newStr</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">source</span><span class="p">));</span>
    <span class="n">free</span><span class="p">(</span><span class="n">newStr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">){</span>

    <span class="n">copyAndFreeString</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="test-with-valgrind">Test with Valgrind</h4> <p>Now let’s consider to use Valgrind to check for any memory issue in the above program. The developer can try a lot of different options, forgetting about the border case(string greater than 20).</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind ./program 12345678
valgrind ./program hello world
valgrind ./program <span class="nb">test</span>
...
</code></pre></div></div> <p>The result for all this test looks similar to the following for the first command execution.</p> <pre><code class="language-log">==9019== Memcheck, a memory error detector
==9019== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==9019== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info
==9019== Command: ./program 12345678
==9019== 
==9019== 
==9019== HEAP SUMMARY:
==9019==     in use at exit: 0 bytes in 0 blocks
==9019==   total heap usage: 2 allocs, 2 frees, 72,724 bytes allocated
==9019== 
==9019== All heap blocks were freed -- no leaks are possible
==9019== 
==9019== For lists of detected and suppressed errors, rerun with: -s
==9019== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre> <p>As you can see, it seems like everything is working fine, no error, no leak. However the developer missed to execute the border case. What we can learn here is that the greater the number of executions with varied inputs, the greater the chance of discovering subtle errors.</p> <h4 id="test-with-valgrind-and-deepstate">Test with Valgrind and DeepState</h4> <p>Let’s integrate DeepState with the previous code fragment. First of all we remove the main function and we create a <code class="language-plaintext highlighter-rouge">TEST</code> function. This is the Test Harness creation phase, discussed in the previous posts<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">copyAndFreeString</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">source</span><span class="p">){</span>
    <span class="c1">// allocates some space for 20 characters</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">newStr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="o">*</span> <span class="mi">20</span><span class="p">);</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">newStr</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">source</span><span class="p">));</span>
    <span class="n">free</span><span class="p">(</span><span class="n">newStr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">StringCopy</span><span class="p">,</span> <span class="n">CopyAndFreeString</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="n">DeepState_CStrUpToLen</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="s">"abcdefABCDEF"</span><span class="p">);</span>

    <span class="n">ASSUME_GT</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">copyAndFreeString</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>As you can see the same standard structure is used to define a test function with the <code class="language-plaintext highlighter-rouge">TEST</code> macro: we start by providing some symbolic variables, then the pre conditions and finally the post conditions. The post conditions aren’t useful in this situation because we’re simply looking for memory related issues.</p> <p>The compilation process can be started with the following command after specifying the compiler to include the headers for DeepState and to include debugging information in the final binary</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-ldeepstate</span> <span class="nt">-o</span> program <span class="nt">-g</span> program.cpp
</code></pre></div></div> <p>This time instead of running Valgrind and DeepState separated we can run them together to achieve the maximum performance</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>valgrind <span class="nt">--tool</span><span class="o">=</span>memcheck ./program <span class="nt">--fuzz</span> <span class="nt">--timeout</span><span class="o">=</span>1
</code></pre></div></div> <pre><code class="language-log">==16724== Memcheck, a memory error detector
==16724== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==16724== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info
==16724== Command: ./program --fuzz --timeout=1
==16724== 
INFO: Starting fuzzing
WARNING: No seed provided; using 1653599264
WARNING: No test specified, defaulting to first test defined (StringCopy_CopyAndFreeString)
==16724== Invalid write of size 8
==16724==    at 0x484FA11: memmove (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==16724==    by 0x114D25: copyAndFreeString(char*) (program.cpp:11)
==16724==    by 0x114E6B: DeepState_Test_StringCopy_CopyAndFreeString() (program.cpp:26)
==16724==    by 0x114D3D: DeepState_Run_StringCopy_CopyAndFreeString() (program.cpp:23)
==16724==    by 0x10FD10: DeepState_RunTestNoFork (in /home/fabri/test/testHarness/TestHarnessSample/program)
==16724==    by 0x110234: DeepState_FuzzOneTestCase (in /home/fabri/test/testHarness/TestHarnessSample/program)
==16724==    by 0x1104C7: DeepState_Fuzz (in /home/fabri/test/testHarness/TestHarnessSample/program)
==16724==    by 0x10B98A: main (in /home/fabri/test/testHarness/TestHarnessSample/program)
==16724==  Address 0x4df6cf0 is 16 bytes inside a block of size 20 alloc'd
==16724==    at 0x4845888: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==16724==    by 0x114CFF: copyAndFreeString(char*) (program.cpp:9)
==16724==    by 0x114E6B: DeepState_Test_StringCopy_CopyAndFreeString() (program.cpp:26)
==16724==    by 0x114D3D: DeepState_Run_StringCopy_CopyAndFreeString() (program.cpp:23)
==16724==    by 0x10FD10: DeepState_RunTestNoFork (in /home/fabri/test/testHarness/TestHarnessSample/program)
==16724==    by 0x110234: DeepState_FuzzOneTestCase (in /home/fabri/test/testHarness/TestHarnessSample/program)
==16724==    by 0x1104C7: DeepState_Fuzz (in /home/fabri/test/testHarness/TestHarnessSample/program)
==16724==    by 0x10B98A: main (in /home/fabri/test/testHarness/TestHarnessSample/program)

    ... truncated file ...

INFO: Done fuzzing! Ran 1 tests (1 tests/second) with 0 failed/1 passed/0 abandoned tests
==16724== 
==16724== HEAP SUMMARY:
==16724==     in use at exit: 0 bytes in 0 blocks
==16724==   total heap usage: 3 allocs, 3 frees, 72,754 bytes allocated
==16724== 
==16724== All heap blocks were freed -- no leaks are possible
==16724== 
==16724== For lists of detected and suppressed errors, rerun with: -s
==16724== ERROR SUMMARY: 6 errors from 3 contexts (suppressed: 0 from 0)
</code></pre> <p>This time the results are quite different: Valgrind with the auxiliary of DeepState was able to discover 6 errors from 3 different contexts. As we can see from the analysis of Valgrind (I have truncated the analysis to only the first error) the error is caused by the <code class="language-plaintext highlighter-rouge">memmove</code> invocated by <code class="language-plaintext highlighter-rouge">memcpy</code> in the program ad line <code class="language-plaintext highlighter-rouge">11</code>.</p> <h2 id="conclusion">Conclusion</h2> <p>Using only one tool is not always the best approach to find subtle programming errors. In fact in this article we discussed a advanced technique to perform a more sophisticated analysis. By combining fuzz testing from DeepState with memory analysis from Valgrind we were able to address more errors than the one we could have discovered by using a single technique.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p><a href="https://valgrind.org/info/tools.html" rel="external nofollow noopener" target="_blank">Valgrind tools</a> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:2"> <p><a href="https://cwe.mitre.org/data/definitions/122.html" rel="external nofollow noopener" target="_blank">Heap overflow</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p> </li> <li id="fn:3"> <p><a href="https://fabriziosandri.github.io/gsoc-2022-blog/deepstate/2022/05/25/about-deepstate.html">Test Harness creation guide</a> <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Fabrizio Sandri. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-0HTGSMCLSW"></script> <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag('js', new Date());

    gtag('config', 'G-0HTGSMCLSW');
  </script> <script defer src="/assets/js/google-analytics-setup.js?12374742c4b1801ba82226e617af7e2d"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>